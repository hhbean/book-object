# OOP

## 객체지향 프로그래밍
**협력, 객체, 클래스**  
1. 클래스가 아닌 객체에 초점을 맞출 때 얻을 수 있음
2. 클래스는 공통적인 행동을 공유하는 객체들을 추상화 한 것
3. 객체는 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체 일원
4. 객체는 고립된 존재가 아닌 협력에 참여하는 협력자
5. 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고,  
  이 타입을 기반으로 클래스를 구현

**클래스 구현**
> 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤부분을 감출지 결정하는 것  
> 구분의 이유? 경계의 명확성이 객체의 자율성을 보장하기 때문 -> 프로그래머 구현의 자유를 제공

1.자율적인 객체
 - 객체는 상태(State)와 행동(Behavior)을 가진다. (캡슐화)
 - 객체는 스스로 판단하고 행동하는 자율적인 존재다. (접근제어)
 - 접근 수정자를 이용한 접근제어 메커니즘 적용  
   이는 객체를 자율적인 존재로 만듦
> 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것
 - Public Interface : 외부에서 접근 가능한 부분
 - Implementation : 내부에서만 접근 가능한 부분
> 인터페이스와 구현의 분리(Separation of interface and implementation) 원칙은  
> 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심원칙
 - 일반적으로 객체의 상태는 숨기고 행동만 외부에 공개한다.

2.프로그래머의 자유
 - Implementation Hiding(구현은닉)  
   클라이언트 프로그래머에게 필요한 부분만 공개하여 숨긴 부분에 접근 할 수 없도록 방지함.
   클래스 작성자는 클라이언트 프로그래머에 대한 영향을 걱정하지 않고 내부 구현을 마음대로 변경
 - 클라이언트 프로그래머는 내부의 구현은 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있다.
 - 클래스 작성자는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정않고, 내부 구현을 변경할 수 있다.
> 설계가 필요한 이유는 변경을 관리하기 위해서.  
> 객체지향 언어는 객체 사이의 의존성을 적절히 관리함으로써 변경에 대한     
> 파급효과를 제어할 수 있는 다양한 방법을 제공한다.

**협력**
 - 객체와 객체의 상호작용(협력)의 유일한 방법은 메시지를 전송하고 수신하는 것이다.
 - 메시지를 처리하는 방법은 객체 스스로 결정하며 방법의 정의는 메소드이다.
 - 객체지향 패러다임의 다형성(Polymorphism) 개념은 메시지와 메소드를 구분하는것에서 출발한다.  
   -> 확장 가능하며, 재사용 가능한 설계

**TEMPLATE METHOD 패턴**  
<img src="https://user-images.githubusercontent.com/67268117/85926418-4d733a80-b8da-11ea-837e-aff934987567.jpg" width="650" />
 - 추상화(Abstraction)를 통한 상속(Inheritance)과 다형성(Polymorphism)
 - 공통 기능을 추상클래스 혹은 인터페이스에 두고, 서로 다른 기능은 자식클래스에서 구현한다.
 - 부모클래스에 기본적인 알고리즘 흐름을 구현하고, 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴
 - 동작 전에는 어떤 메소드가 호출될지 알 수 없다.

**오버로딩과 오버라이딩**
 - 오버로딩 (Overloading) : 이름 같음 / 파라미터 or 리턴값 다름
 - 오버라이딩 (Overriding) : 이름 같음 / 부모에 정의된 메소드 모양 그대로 자식에서 새롭게 or 추가하여 구현  
   자식으로 생성 시 자식쪽에 재정의된 메소드를 호출하게 된다.

## 상속과 다형성
**컴파일 시간 의존성과 실행 시간 의존성**  
<img src="https://user-images.githubusercontent.com/67268117/85935524-e763d300-b92c-11ea-89c8-8cd9d0bffbf6.jpg" width="650">  
Movie가 Abstract Class인 DiscountPolicy에만 의존하는 이유?
 - Movie는 코드 작성 시점에 AmountDiscountPolicy와 PercentDiscountPolicy의 존재를 알지 못한다.
 - 실행 시점, 할인 방법에 따라 Movie는 AmountDiscountPolicy와 PercentDiscountPolicy에 의존하게 된다.
> 코드의 의존성과 실행 시점의 의존성은 서로 다를 수 있다.  
> 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.  
> 이는 유연하고 재사용성이 좋고, 확장 가능한 객체지향 설계의 특징을 나타낸다.
 - 하지만 이 또한 트레이드오프의 산물 (유연함, 재사용성, 확장성 vs 코드의 이해도)

**상속과 인터페이스**  
1.차이에 의한 프로그래밍  
 : 부모클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법 (상속)

2.상속
 - 상속은 객체지향에서 코드 재사용을 위해 가장 널리 사용되는 방법
 - 코드 중복을 제거, 여러 클래스 사이에서 동일한 코드를 공유
 - 부모클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받음
 - 자식클래스는 부모클래스 대신 사용될 수 있다 (자동 업캐스팅)

3.다형성
 - 메시지와 메소드는 다르다!  
   메시지 : 호출하라고 명시한 메소드명  
   메소드 : 실제 호출되는 메소드 (부모 메소드를 오버라이딩 한 자식클래스의 메소드 중 무엇이 호출될지 모름)
 - 부모타입으로 선언된 객체로, getDiscountAmount()를 호출하지만  
   실제 어떤 메소드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가  
   무엇이냐에 따라 달라지는데 이를 다형성 이라고 한다.
 - 다형성은 객체지향 프로그램의 컴파일 시간의존성과 실행 시간의존성이 다를 수 있다는 사실을 기반으로 한다.
 - 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다. (상속)
 - 다형성은 메시지와 메소드를 실행시점에 바인딩 한다. (동적바인딩)
 - 하지만, 상속말고 다형성을 구현할 수 있는 다른 방법도 있다!

**인터페이스와 다형성**
 - 구현 공유 없이, 순수하게 인터페이스만 공유하고 싶은 경우
 - 동일한 인터페이스를 공유하는 경우도 업캐스팅이 적용되며 협력은 다형적이다.

## 추상화와 유연성
**추상화의 장점**  
1.추상화 계층만 따로 떼어 놓고 보면, 요구사항의 정책을 높은 수준에서 서술 가능
 - 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단히 표현할 수 있다.    
   (할인의 방법과 종류는 알 필요 없이, 할인이 있다는 것만 표현할 수 있다.)  
 - 디자인 패턴, 프레임워크 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용한다.

2.설계가 좀 더 유연해 진다.
- 기존 구조를 수정하지 않고, 새로운 기능을 쉽게 추가하고 확장할 수 있다.

**유연한 설계**
 - 컨텍스트 독립성 : 추상화를 이용하면 기존 코드 수정없이 기능확장이 가능
 - 유연성이 필요한 곳에 추상화를 사용하기

**코드 재사용**  
 - 코드 재사용을 위해 사용되는 방법은 합성(Composition)과 상속(Inheritance)이 있다.

**상속(Inheritance)**
 - 문제점 1 : 캡슐화를 위반한다  
   상속을 이용하려면 부모클래스의 내부구조를 알아야 한다.  
   부모클래스의 구현이 자식클래스에 노출되므로 캡슐화가 약화된다.
 - 문제점 2 : 코드 변경이 어려워진다.  
   자식클래스와 부모클래스의 결합도가 높아지기 때문이다.  
   상속이 아닌 인스턴스 변수로 포함시켜 사용하면 변경에 더 유연한 코드가 된다. (합성)

**합성(Composition)**
 - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이 합성
 - 합성은 상속의 두 가지 문제를 모두 해결한다.  
   인터페이스에 정의된 메시지를 통해서만 재사용 가능하므로 구현을 효과적으로 캡슐화 한다.  
   의존하는 인스턴스를 교체하는 것이 비교적 쉬워 설계를 유연하게 만든다.
